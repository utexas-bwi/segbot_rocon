#! /usr/bin/env python

import actionlib
import rospy
import tf
import thread

from geometry_msgs.msg import Quaternion
from move_base_msgs.msg import MoveBaseAction, MoveBaseGoal
from segbot_navigation_concert.msg import AvailableRobotArray

# TODO read from service parameters
points = [(0, 8, 0), (0, 16, 0)]
available_robots = []
global_start_counter = 0
global_forward = True

def navigate_robot(robot_name, start_counter, forward):

    client = actionlib.SimpleActionClient('/' + robot_name + '/move_base_interruptable', MoveBaseAction)
    resolved_frame = '/' + robot_name + '/level_mux/map'

    # Waits until the action server has started up and started
    # listening for goals.
    while not rospy.is_shutdown():
        if client.wait_for_server(rospy.Duration(1)):
            break

    counter = start_counter
    while not rospy.is_shutdown():
        # Creates a goal to send to the action server.
        goal = MoveBaseGoal()
        goal.target_pose.header.frame_id = resolved_frame
        goal.target_pose.header.stamp = rospy.get_rostime()
        goal.target_pose.pose.position.x = points[counter][0]
        goal.target_pose.pose.position.y = points[counter][1]
        goal.target_pose.pose.position.z = 0.0
        q = tf.transformations.quaternion_from_euler(0, 0, points[counter][2])
        goal.target_pose.pose.orientation = Quaternion(*q)

        # Sends the goal to the action server.
        client.send_goal(goal)

        # Waits for the server to finish performing the action.
        while not rospy.is_shutdown():
            if client.wait_for_result(rospy.Duration(1)):
                break
        if forward:
            counter = (counter + 1) % len(points)
        else:
            counter = counter - 1
            if counter < 0:
                counter = len(points) - 1

def available_robot_callback(msg):
    for robot_resource in msg.robot_names:
        results = robot_resource.split('/')
        robot_name = results[2]
        if robot_name not in available_robots:
            available_robots.append(robot_name)
            thread.start_new_thread(robot_name, global_start_counter, global_forward)
            global_forward = not global_forward
            global_start_counter = (global_start_counter + 1) % len(points)

def random_navigator():
    rospy.Subscriber("available_robots", AvailableRobotArray, available_robot_callback)

if __name__ == '__main__':
    try:
        rospy.init_node('random_navigator')
        random_navigator()
    except rospy.ROSInterruptException:
        pass
